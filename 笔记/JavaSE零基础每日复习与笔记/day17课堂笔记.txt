day17课堂笔记

1、继承extends
	
	1.1、测试：子类继承父类之后，能使用子类对象调用父类方法吗？
		可以，因为子类继承了父类之后，这个方法就属于子类了。
		当然可以使用子类对象来调用。

	1.2、在实际开发中，满足什么条件的时候，我可以使用继承呢？
		凡是采用“is a”能描述的，都可以继承。
		例如：
			Cat is a Animal：猫是一个动物
			Dog is a Animal：狗是一个动物
			CreditAccount is a Account：信用卡账户是一个银行账户
			....
		
		假设以后的开发中有一个A类，有一个B类，A类和B类确实也有重复的代码，
		那么他们两个之间就可以继承吗？不一定，还是要看一看它们之间是否能够
		使用is a来描述。

			class Customer{
				String name; // 名字
				// setter and getter
			}

			class Product{
				String name; // 名字
				// setter and getter
			}

			class Product extends Customer{
			
			}

			以上的继承就属于很失败的。因为：Product is a Customer，是有违伦理的。

	1.3、任何一个类，没有显示继承任何类，默认继承Object，那么Object类当中有
	哪些方法呢？老祖宗为我们提供了哪些方法？

		以后慢慢的大家一定要适应看JDK的源代码（多看看牛人写的程序自己才会变成牛人。）
		先模仿后超越。
		java为什么比较好学呢？
			是因为Java内置了一套庞大的类库，程序员不需要从0开始写代码，程序员可以
			基于这套庞大的类库进行“二次”开发。（开发速度较快，因为JDK内置的这套库
			实现了很多基础的功能。）

			例如：String是SUN编写的字符串类、System是SUN编写的系统类。
			这些类都可以拿来直接使用。
		
		JDK源代码在什么位置？
			C:\Program Files\Java\jdk-13.0.2\lib\src.zip
		
		你现在能看懂以下代码了吗？
			System.out.println("Hello World!");
			System.out 中，out后面没有小括号，说明out是变量名。
			另外System是一个类名，直接使用类名System.out，说明out是一个静态变量。
			System.out 返回一个对象，然后采用“对象.”的方式访问println()方法。
		
		我们研究了一下Object类当中有很多方法，大部分看不懂，其中有一个叫做toString()
		的，我们进行了测试，发现：
			System.out.println(引用);
			当直接输出一个“引用”的时候，println()方法会先自动调用“引用.toString()”，然后
			输出toString()方法的执行结果。
		
2、方法覆盖
	
	2.1、什么时候考虑使用方法覆盖？
		父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。

	2.2、什么条件满足的时候构成方法覆盖？
		第一：有继承关系的两个类
		第二：具有相同方法名、返回值类型、形式参数列表
		第三：访问权限不能更低。
		第四：抛出异常不能更多。

	2.3、关于Object类中toString()方法的覆盖？
		toString()方法存在的作用就是：将java对象转换成字符串形式。
		大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()
		方法输出的是一个java对象的内存地址。

		至于toString()方法具体怎么进行覆盖？
			格式可以自己定义，或者听需求的。（听项目要求的。）

	2.4、方法重载和方法覆盖有什么区别？

		方法重载发生在同一个类当中。

		方法覆盖是发生在具有继承关系的父子类之间。

		方法重载是一个类中，方法名相同，参数列表不同。

		方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：
			方法名一致、参数列表一致、返回值类型一致。

3、多态的基础语法
	
	3.1、向上转型和向下转型的概念。

		向上转型：子--->父 (upcasting)
			又被称为自动类型转换：Animal a = new Cat();

		向下转型：父--->子 (downcasting)
			又被称为强制类型转换：Cat c = (Cat)a; 需要添加强制类型转换符。
			什么时候需要向下转型？
				需要调用或者执行子类对象中特有的方法。
				必须进行向下转型，才可以调用。
			向下转型有风险吗？
				容易出现ClassCastException（类型转换异常）
			怎么避免这个风险？
				instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象
				是否为某一种类型。
				养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。
		
		不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。

	3.2、什么是多态。
		多种形态，多种状态，编译和运行有两个不同的状态。
		编译期叫做静态绑定。
		运行期叫做动态绑定。
		Animal a = new Cat();
		// 编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move()方法
		// 找到了，绑定，编译通过。但是运行的时候和底层堆内存当中的实际对象有关
		// 真正执行的时候会自动调用“堆内存中真实对象”的相关方法。
		a.move();

		多态的典型代码：父类型的引用指向子类型的对象。（java中允许这样写代码！！！）

	3.3、什么时候必须进行向下转型？
		调用子类对象上特有的方法时。