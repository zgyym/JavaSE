// 主人类
public class Master{

	/*
	// 假设主人起初的时候只是喜欢养宠物狗狗
	// 喂养宠物狗狗
	public void feed(Dog d){
		d.eat();
	}

	// 由于新的需求产生，导致我们“不得不”去修改Master这个类的代码
	public void feed(Cat c){
		c.eat();
	}
	*/
	
	// 能不能让Master主人这个类以后不再修改了。
	// 即使主人又喜欢养其它宠物了，Master也不需要修改。
	// 这个时候就需要使用：多态机制。
	// 最好不要写具体的宠物类型，这样会影响程序的扩展性。
	public void feed(Pet pet){ 
		// 编译的时候，编译器发现pet是Pet类，会去Pet类中找eat()方法，结果找到了，编译通过
		// 运行的时候，底层实际的对象是什么，就自动调用到该实际对象对应的eat()方法上。
		// 这就是多态的使用。
		pet.eat();
	}

}

/*

	注意这里的分析：
		主人起初的时候只喜欢养宠物狗狗
		随着时间的推移，主人又喜欢上养“猫咪”
		在实际的开发中这就表示客户产生了新的需求。
		作为软件的开发人员来说，必须满足客户的需求。
		我们怎么去满足客户的需求呢？
			在不使用多态机制的前提下，目前我们只能在Master类中添加一个新的方法。
	
	思考：软件在扩展新需求过程当中，修改Master这个类有什么问题？
		一定要记住：软件在扩展过程当中，修改的越少越好。
		修改的越多，你的系统当前的稳定性就越差，未知的风险就越多。

		其实这里涉及到一个软件的开发原则：
			软件开发原则有七大原则（不属于java，这个开发原则属于整个软件业）：
				其中有一条最基本的原则：OCP（开闭原则）

		什么是开闭原则？
			对扩展开放（你可以额外添加，没问题），对修改关闭（最好很少的修改现有程序）。
			在软件的扩展过程当中，修改的越少越好。
	

	高手开发项目不是仅仅为了实现客户的需求，还需要考虑软件的扩展性。

	什么是软件扩展性？
		假设电脑中的内存条部件坏了，我们可以买一个新的插上，直接使用。
		这个电脑的设计就考虑了“扩展性”。内存条的扩展性很好。
	
	面向父类型编程，面向更加抽象进行编程，不建议面向具体编程。
	因为面向具体编程会让软件的扩展力很差。

*/